
//*******************************************************************************//
#ifndef __playvideo_h_REVISION_FIRST__
#define __playvideo_h_REVISION_FIRST__
//****************************************************************************//
#include "Global.h"
#include "lcd.h"

//---重定义关键词---//
#ifndef uchar
#define uchar unsigned char
#endif
#ifndef uint 
#define uint unsigned int
#endif
#ifndef ulong
#define ulong unsigned long

#define N 3 //总共3首

//*****************************************************************************//
#define OSC 		12000000	    //定义晶振频率12MHZ
#define SOUND_SPACE 	4/5 	    //定义普通音符演奏的长度分率,//每4分音符间隔
//****************************红外模块定义区间*********************************//
sbit IRIN=P3^2;
uchar IrValue[6];          //存读取到的数据
uchar Time;
bit Next=0;
//*****************************************************************
bit Status=1;                            //0,暂停,1,运行
bit IsMusic=0;                           //是否放歌中,控制T0放歌的选择项
char musicNum;                           //曲目序数(可负)
uint  code FreTab[12]  = { 262,277,294,311,330,349,369,392,415,440,466,494 }; //1-7低音原始频率表
uchar code SignTab[7]  = { 0,2,4,5,7,9,11 }; 								  //1~7在频率表中的位置
uchar code LengthTab[7]= { 1,2,4,8,16,32,64 };						
uchar Sound_Temp_TH0,Sound_Temp_TL0;	//音符定时器初值暂存 
uchar Sound_Temp_TH1,Sound_Temp_TL1;	//音长定时器初值暂存
//*******************函数列表*************************
void Initial(void);//初始化音乐
void BeepT0(void);//音符中断
void Playvideo(uchar num,uchar Signature,uchar Octachord,uint Speed);//放音乐
void UDshow(uchar number);
//******************端口位定义*************************
sbit BeepIO=P3^7;		     //播放音乐输出管脚
//******************内置数据***************************
uchar code Music_hzcb[]={//挥着翅膀的女孩
   0x17,0x02, 0x17,0x03, 0x18,0x03, 0x19,0x02, 0x15,0x03,
   0x16,0x03, 0x17,0x03, 0x17,0x03, 0x17,0x02, 0x18,0x03,
   0x19,0x02, 0x16,0x03, 0x17,0x03, 0x18,0x02, 0x18,0x03,
   0x17,0x03, 0x15,0x02, 0x18,0x03, 0x17,0x03, 0x18,0x02,
   0x10,0x03, 0x15,0x03, 0x16,0x02, 0x15,0x03, 0x16,0x03,
   0x17,0x02, 0x17,0x03, 0x18,0x03, 0x19,0x02, 0x1A,0x03,
   0x1B,0x03, 0x1F,0x03, 0x1F,0x03, 0x17,0x03, 0x18,0x03,
   0x19,0x02, 0x16,0x03, 0x17,0x03, 0x18,0x03, 0x17,0x03,
   0x18,0x03, 0x1F,0x03, 0x1F,0x02, 0x16,0x03, 0x17,0x03,
   0x18,0x03, 0x17,0x03, 0x18,0x03, 0x20,0x03, 0x20,0x02,
   0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 0x20,0x03, 0x21,0x03,
   0x20,0x03, 0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 0x1F,0x03,
   0x1B,0x03, 0x19,0x03, 0x19,0x03, 0x15,0x03, 0x1A,0x66,
   0x1A,0x03, 0x19,0x03, 0x15,0x03, 0x15,0x03, 0x17,0x03,
   0x16,0x66, 0x17,0x04, 0x18,0x04, 0x18,0x03, 0x19,0x03,
   0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 0x20,0x03, 0x21,0x03,
   0x20,0x03, 0x1F,0x03, 0x1B,0x03, 0x1F,0x66, 0x1F,0x03,
   0x1B,0x03, 0x19,0x03, 0x19,0x03, 0x15,0x03, 0x1A,0x66,
   0x1A,0x03, 0x19,0x03, 0x19,0x03, 0x1F,0x03, 0x1B,0x03,
   0x1F,0x00, 0x1A,0x03, 0x1A,0x03, 0x1A,0x03, 0x1B,0x03,
   0x1B,0x03, 0x1A,0x03, 0x19,0x03, 0x19,0x02, 0x17,0x03,
   0x15,0x17, 0x15,0x03, 0x16,0x03, 0x17,0x03, 0x18,0x03,
   0x17,0x04, 0x18,0x0E, 0x18,0x03, 0x17,0x04, 0x18,0x0E,
   0x18,0x66, 0x17,0x03, 0x18,0x03, 0x17,0x03, 0x18,0x03,
   0x20,0x03, 0x20,0x02, 0x1F,0x03, 0x1B,0x03, 0x1F,0x66,
   0x20,0x03, 0x21,0x03, 0x20,0x03, 0x1F,0x03, 0x1B,0x03,
   0x1F,0x66, 0x1F,0x04, 0x1B,0x0E, 0x1B,0x02, 0x19,0x03,
   0x19,0x03, 0x15,0x03, 0x1A,0x66, 0x1A,0x03, 0x19,0x03,
   0x15,0x03, 0x15,0x03, 0x17,0x03, 0x16,0x66, 0x17,0x04,
   0x18,0x04, 0x18,0x03, 0x19,0x03, 0x1F,0x03, 0x1B,0x03,
   0x1F,0x66, 0x20,0x03, 0x21,0x03, 0x20,0x03, 0x1F,0x03,
   0x1B,0x03, 0x1F,0x66, 0x1F,0x03, 0x1B,0x03, 0x19,0x03,
   0x19,0x03, 0x15,0x03, 0x1A,0x66, 0x1A,0x03, 0x19,0x03,
   0x19,0x03, 0x1F,0x03, 0x1B,0x03, 0x1F,0x00, 0x18,0x02,
   0x18,0x03, 0x1A,0x03, 0x19,0x0D, 0x15,0x03, 0x15,0x02,
   0x18,0x66, 0x16,0x02, 0x17,0x02, 0x15,0x00, 0xff,0xff
                               };

uchar code Music_tyshg[]={ //同一首歌
  0x0F,0x01, 0x15,0x02, 0x16,0x02, 0x17,0x66, 0x18,0x03,
  0x17,0x02, 0x15,0x02, 0x16,0x01, 0x15,0x02, 0x10,0x02,
  0x15,0x00, 0x0F,0x01, 0x15,0x02, 0x16,0x02, 0x17,0x02,
  0x17,0x03, 0x18,0x03, 0x19,0x02, 0x15,0x02, 0x18,0x66,
  0x17,0x03, 0x19,0x02, 0x16,0x03, 0x17,0x03, 0x16,0x00,
  0x17,0x01, 0x19,0x02, 0x1B,0x02, 0x1B,0x70, 0x1A,0x03,
  0x1A,0x01, 0x19,0x02, 0x19,0x03, 0x1A,0x03, 0x1B,0x02,
  0x1A,0x0D, 0x19,0x03, 0x17,0x00, 0x18,0x66, 0x18,0x03,
  0x19,0x02, 0x1A,0x02, 0x19,0x0C, 0x18,0x0D, 0x17,0x03,
  0x16,0x01, 0x11,0x02, 0x11,0x03, 0x10,0x03, 0x0F,0x0C,
  0x10,0x02, 0x15,0x00, 0x1F,0x01, 0x1A,0x01, 0x18,0x66,
  0x19,0x03, 0x1A,0x01, 0x1B,0x02, 0x1B,0x03, 0x1B,0x03,
  0x1B,0x0C, 0x1A,0x0D, 0x19,0x03, 0x17,0x00, 0x1F,0x01,
  0x1A,0x01, 0x18,0x66, 0x19,0x03, 0x1A,0x01, 0x10,0x02,
  0x10,0x03, 0x10,0x03, 0x1A,0x0C, 0x18,0x0D, 0x17,0x03,
  0x16,0x00, 0x0F,0x01, 0x15,0x02, 0x16,0x02, 0x17,0x70,
  0x18,0x03, 0x17,0x02, 0x15,0x03, 0x15,0x03, 0x16,0x66,
  0x16,0x03, 0x16,0x02, 0x16,0x03, 0x15,0x03, 0x10,0x02,
  0x10,0x01, 0x11,0x01, 0x11,0x66, 0x10,0x03, 0x0F,0x0C,
  0x1A,0x02, 0x19,0x02, 0x16,0x03, 0x16,0x03, 0x18,0x66,
  0x18,0x03, 0x18,0x02, 0x17,0x03, 0x16,0x03, 0x19,0x00,
  0xff,0xff  //0xff休止符号
                         };

uchar code Music_lzhd[]={  //两只蝴蝶
  0x17,0x03, 0x16,0x03, 0x17,0x01, 0x16,0x03, 0x17,0x03,
  0x16,0x03, 0x15,0x01, 0x10,0x03, 0x15,0x03, 0x16,0x02,
  0x16,0x0D, 0x17,0x03, 0x16,0x03, 0x15,0x03, 0x10,0x03,
  0x10,0x0E, 0x15,0x04, 0x0F,0x01, 0x17,0x03, 0x16,0x03,
  0x17,0x01, 0x16,0x03, 0x17,0x03, 0x16,0x03, 0x15,0x01,
  0x10,0x03, 0x15,0x03, 0x16,0x02, 0x16,0x0D, 0x17,0x03,
  0x16,0x03, 0x15,0x03, 0x10,0x03, 0x15,0x03, 0x16,0x01,
  0x17,0x03, 0x16,0x03, 0x17,0x01, 0x16,0x03, 0x17,0x03,
  0x16,0x03, 0x15,0x01, 0x10,0x03, 0x15,0x03, 0x16,0x02,
  0x16,0x0D, 0x17,0x03, 0x16,0x03, 0x15,0x03, 0x10,0x03,
  0x10,0x0E, 0x15,0x04, 0x0F,0x01, 0x17,0x03, 0x19,0x03,
  0x19,0x01, 0x19,0x03, 0x1A,0x03, 0x19,0x03, 0x17,0x01,
  0x16,0x03, 0x16,0x03, 0x16,0x02, 0x16,0x0D, 0x17,0x03,
  0x16,0x03, 0x15,0x03, 0x10,0x03, 0x10,0x0D, 0x15,0x00,
  0x19,0x03, 0x19,0x03, 0x1A,0x03, 0x1F,0x03, 0x1B,0x03,
  0x1B,0x03, 0x1A,0x03, 0x17,0x0D, 0x16,0x03, 0x16,0x03,
  0x16,0x0D, 0x17,0x01, 0x17,0x03, 0x17,0x03, 0x19,0x03,
  0x1A,0x02, 0x1A,0x02, 0x10,0x03, 0x17,0x0D, 0x16,0x03,
  0x16,0x01, 0x17,0x03, 0x19,0x03, 0x19,0x03, 0x17,0x03,
  0x19,0x02, 0x1F,0x02, 0x1B,0x03, 0x1A,0x03, 0x1A,0x0E,
  0x1B,0x04, 0x17,0x02, 0x1A,0x03, 0x1A,0x03, 0x1A,0x0E,
  0x1B,0x04, 0x1A,0x03, 0x19,0x03, 0x17,0x03, 0x16,0x03,
  0x17,0x0D, 0x16,0x03, 0x17,0x03, 0x19,0x01, 0x19,0x03,
  0x19,0x03, 0x1A,0x03, 0x1F,0x03, 0x1B,0x03, 0x1B,0x03,
  0x1A,0x03, 0x17,0x0D, 0x16,0x03, 0x16,0x03, 0x16,0x03,
  0x17,0x01, 0x17,0x03, 0x17,0x03, 0x19,0x03, 0x1A,0x02,
  0x1A,0x02, 0x10,0x03, 0x17,0x0D, 0x16,0x03, 0x16,0x01,
  0x17,0x03, 0x19,0x03, 0x19,0x03, 0x17,0x03, 0x19,0x03,
  0x1F,0x02, 0x1B,0x03, 0x1A,0x03, 0x1A,0x0E, 0x1B,0x04,
  0x17,0x02, 0x1A,0x03, 0x1A,0x03, 0x1A,0x0E, 0x1B,0x04,
  0x17,0x16, 0x1A,0x03, 0x1A,0x03, 0x1A,0x0E, 0x1B,0x04,
  0x1A,0x03, 0x19,0x03, 0x17,0x03, 0x16,0x03, 0x0F,0x02,
  0x10,0x03, 0x15,0x00, 0xff,0xff
                              };
uchar *Sound[N]={Music_hzcb,Music_tyshg,Music_lzhd};          //指向歌曲数组的指针,可为music.Name[N]
uchar *MusicName[N]={"hzcb ","tyshg","lzhd "};                //歌曲名字,长度为5,LCD1602显示用
//uint SoundLength[N];                                        //对应歌曲的长度,可为music.Len[N]
uint Point=0;                                                 //播放音符的位置,清零				

//****************************************************************
void Initial(void)
{
	BeepIO = 0;
	Sound_Temp_TH1 = (65535-(1/1200)*OSC)/256;	// 计算TL1应装入的初值 	(10ms的初装值)
	Sound_Temp_TL1 = (65535-(1/1200)*OSC)%256;	// 计算TH1应装入的初值 
	TH1 = Sound_Temp_TH1;
	TL1 = Sound_Temp_TL1;
	TR1 = 1;                                    //--- 启动定时器T1 ---
  ET1 = 0;                                    //--- 关闭定时器T1溢出中断源---
  IT1 = 1;                                    //--- INT1外部中断源下降沿触发 ---
  EX1 = 1;                                    //--- 使能INT1外部中断源 ---
  PT1 = 1;                                    //--- 允许T1高优先级中断 ---
}
//*****************************放歌状态显示函数****************************
void UDshow(uchar number)
{
	uchar up,down;
	
	if(number==0)
   {
     up=N-1;
		 down=1; 
   }
	if(number>0)
	 {
		 up=number-1;
		 down=number+1;
	 }
	if(number==(N-1))
	 {
     up=N-2;
		 down=0;
	 }
	 LcdShowStr(2,0,MusicName[up]);
	 delayms(10);
	 LcdShowStr(10,0,MusicName[down]);
}
//******外部中断源INT1的中断服务程序，选播下一曲按键操作，可使音乐序数增一***************
void Int1(void ) interrupt 2                                      //延迟约0.5s
{
    EX1 = 0;                                                      //禁止INT1中断源
	  if(IsMusic)
		{
      musicNum++;                                                 //下一曲
      if(N==musicNum)musicNum=0;                                  //到达最大序数归零,循环选曲
      while(0 == INT1);                                       		//等待按键释放
	    Point=0;                                                   	//音符位置清零
			Next=1;
		}
    EX1 = 1;                                                      //使能INT1中断源
    IE1 = 0;                                                      //清中断标志 
}
//**********************电子琴和音乐盒发声器***********************************
void BeepT0(void) interrupt 1                                   	//音符发生中断
{
	if(IsMusic)
	 {
	   TH0 = Sound_Temp_TH0;
 	   TL0 = Sound_Temp_TL0;
	 }
	 else
	 {
		 TH0 = (Tonetab[ALL])/256;
     TL0 = (Tonetab[ALL])%256;       //重装值
   }
	 BeepIO = !BeepIO;
}
//***************************主放歌处理函数*********************************
void Playvideo(uchar num,uchar Signature,uchar Octachord,uint Speed)
{
	uint LDiv,LDiv0,LDiv1,LDiv2,LDiv4,CurrentFre,Temp_T;
  uchar Tone,Length,SL,SH,SM,SLen,XG,FD;
	uint NewFreTab[12];													//新的频率表
	
	IsMusic=1;
	BeepIO=0;
	Status=1;                                   //默认是可播放,初始化
	musicNum=num%N;                             //自选歌曲作为起始                     
	ET1=0;                                      //防止触发100Hz的音调
	LcdShowStr(0,0,udstr);                      //显示当前歌曲上下曲名面板
	delayms(10);
	UDshow(musicNum);                           //显示上下曲名
	delayms(10);
	LcdShowStr(0,1,Playing);                    //显示当前放歌面板
	delayms(10);
	DisplayOneChar(0,1,ASCII[musicNum]);        //显示当前歌曲序号
	delayms(10);
	LcdShowStr(2,1,MusicName[musicNum]);        //显示当前歌曲名
	
	for(i=0;i<12;i++) 	                  			// 根据调号及升降八度来生成新的频率表 
	 {
		j = i + Signature;
		if(j > 11)
		 {
			j = j-12;
			NewFreTab[i] = FreTab[j]*2;
		 }
		else
			NewFreTab[i] = FreTab[j];

		if(Octachord == 1)
			NewFreTab[i]>>=2;
		else if(Octachord == 3)
			NewFreTab[i]<<=2;
	 }				
/*	for(i=0;i<N;i++)
	{
		SoundLength[i] = 0;
	  while(Sound[i][SoundLength[i]] != 0xff)	//计算歌曲长度
	   {
		  SoundLength[i]+=2;
	   }
  }*/
	   Point = 0;                          //音符首个位置
	   Tone   = Sound[musicNum][Point];	
	   Length = Sound[musicNum][Point+1];  // 读出第一个音符和它时时值
	   LDiv0 = 12000/Speed;				         // 算出1分音符的长度(几个10ms) 	
	   LDiv4 = LDiv0/4; 					         // 算出4分音符的长度 
	   LDiv4 = LDiv4-LDiv4*SOUND_SPACE; 	 // 普通音最长间隔标准 
	   TR0	 = 0;                          // 关闭发音
     TR1   = 1;                          // 延时10ms
	
	   while(Sound[musicNum][Point]!=0xff) //是否超出音乐数组有效边界
	     {
				 if(Next)                        //刚从中断中回来不久
				  {
						Next=0;
				 		UDshow(musicNum);            //显示上下曲名
						DisplayOneChar(0,1,ASCII[musicNum]);//显示歌曲序号
						delayms(10);
		        LcdShowStr(2,1,MusicName[musicNum]);//显示歌曲名
				  }
        //******************暂停/续播转换程序**********************
				 if(K2==0)			
	        {
		        delayms(10);
		        if(K2==0)
		          {
							  while(!K2);
			          if(!Status)
		              { 
	                  Status=1;
										LcdShowStr(0,1,Playing);    //显示播放状态
										delayms(10);
										DisplayOneChar(0,1,ASCII[musicNum]);//显示歌曲序号
	                  delayms(10);
								    LcdShowStr(2,1,MusicName[musicNum]);//显示歌曲名
	                }                           //若是暂停状态则，进入运行状态
                else                          //否则进入暂停状态
                  {
                    TR0 = 0;
                    BeepIO = 1;
                    Status = 0;               //仅此位置能改动该值
										LcdShowStr(0,1,Pause);    //显示暂停状态
										delayms(10);
										DisplayOneChar(0,1,ASCII[musicNum]);//序号
	                  delayms(10);
								    LcdShowStr(2,1,MusicName[musicNum]);//曲名
                  }
		          }
	       }
       //**********************主放歌程序*************************
			  if(Status)                          //是否可播放
				 {
						 SL=Tone%10; 								    //计算出音符 
						 LED=Tab[Tone%8];               //LED背景显示
						 SM=Tone/10%10; 								//计算出高低音 
						 SH=Tone/100; 							    //计算出是否升半 
						 CurrentFre = NewFreTab[SignTab[SL-1]+SH]; 	//查出对应音符的频率 	
						 if(SL!=0)
							 {
								 if (SM==1) CurrentFre >>= 2; 		//低音 
								 if (SM==3) CurrentFre <<= 2; 		//高音
								 Temp_T = 65536-(50000/CurrentFre)*10/(12000000/OSC);//计算计数器初值
								 Sound_Temp_TH0 = Temp_T/256; 
								 Sound_Temp_TL0 = Temp_T%256; 
								 TH0 = Sound_Temp_TH0;  
								 TL0 = Sound_Temp_TL0 + 12; //加12是对中断延时的补偿 
							 }
						 SLen=LengthTab[Length%10]; 	  //算出是几分音符
						 XG=Length/10%10; 			        //算出音符类型(0普通1连音2顿音) 
						 FD=Length/100;
						 LDiv=LDiv0/SLen; 		        	//算出连音音符演奏的长度(多少个10ms)
						 if(FD==1) 
							 LDiv=LDiv+LDiv/2;
						 if(XG!=1)	
							 if(XG==0) 				           //算出普通音符的演奏长度 
								 if(SLen<=4)	
									 LDiv1=LDiv-LDiv4;
								else
									 LDiv1=LDiv*SOUND_SPACE;
							else
								 LDiv1=LDiv/2; 	         	//算出顿音的演奏长度 
						else
							LDiv1=LDiv;
						if(SL==0) LDiv1=0;
							LDiv2=LDiv-LDiv1; 	      	//算出不发音的长度 
						if (SL!=0)
							{
								TR0=1;                    //启动发音
								for(i=LDiv1;i>0;i--)    	//发规定长度的音,使用定时器T1
									{
										while(TF1==0);
										TH1 = Sound_Temp_TH1;
										TL1 = Sound_Temp_TL1;
										TF1 = 0;
									}
							}
						if(LDiv2!=0)
							{
								TR0=0; BeepIO=0;       //关闭发音
								for(i=LDiv2;i>0;i--) 	//音符间的间隔
									{
										while(TF1==0);
										TH1 = Sound_Temp_TH1;
										TL1 = Sound_Temp_TL1;
										TF1=0;
									}
							}
							
						Point+=2;                  //右移两位，指向下个音符
						Tone=Sound[musicNum][Point];
						Length=Sound[musicNum][Point+1];
		    }
	//*****************************暂停中检测退出的程序************************************
			  else
				 {
					  if(Next)                        //刚从中断中回来
				      {
								Next=0;
								UDshow(musicNum);           //显示上下曲名
								delayms(10);
								LcdShowStr(0,1,Pause);      //显示暂停状态
								delayms(10);
								DisplayOneChar(0,1,ASCII[musicNum]);//序号
	              delayms(10);
								LcdShowStr(2,1,MusicName[musicNum]);//曲名
//								delayms(800);               //可能影响退出,但可防止lcd1602刷新过快
				      }
						if(K3==0)			
							{
								delayms(10);
								if(K3==0)
									 {
										 while(!K3);
										 break;
									 }
						  }
           if(K1==0)			
							{
								delayms(10);
								if(K1==0)
									 {
										 while(!K1);
										 musicNum--;                             //上一曲
										 if(musicNum==(-1))musicNum=N-1;         //0--,回到N-1,循环选曲
										 Point=0;                                //音符位置清零
										 UDshow(musicNum);                       //显示上下曲名
										 delayms(10);
										 DisplayOneChar(0,1,ASCII[musicNum]);    //序号
	                   delayms(10);
										 LcdShowStr(2,1,MusicName[musicNum]);    //曲名
									 }
						  }
				 }			            
		  }			//退出放歌
			IsMusic=0;                         //控制T0放歌的选择项
			BeepIO=0;
			Point=0;
			LcdShowStr(0,0,welcome);
			delayms(10);
			LcdShowStr(0,1,leave);
}
/*******************************************************************************
* 函 数 名       : READIR_QUIT(void )
* 函数功能		   : 红外和退出
*******************************************************************************/
void READIR(void ) interrupt 0
{
//************************红外接收的程序*********************************
	 uint err;
	 Time=0;
	 IRIN=1;//初始化端口

	 delayus(700);                      	//7ms
	 if(IRIN==0)		                      //确认是否真的接收到正确的信号
		{	 
			err=1000;				                  //10ms,超过说明接收到错误的信号
			while((IRIN==0)&&(err>0))	       //等待前面9ms的低电平过去  		
			 {			
				 delayus(1);
				 err--;
			 }
			 
			if(IRIN==1)			                 //如果正确等到9ms低电平
			 {
					err=500;
					while((IRIN==1)&&(err>0))     //等待4.5ms的起始高电平过去
							{
							 delayus(1);
							 err--;
							}
		     for(k=0;k<4;k++)		          //共有4组数据
				  {				
						for(j=0;j<8;j++)	          //接收一组数据
								{
									err=60;		
									while((IRIN==0)&&(err>0)) //等待信号前面的560us低电平过去
											{
											 delayus(1);
											 err--;
											}
									err=500;
									while((IRIN==1)&&(err>0))	 //计算高电平的时间长度。
											{
											 delayus(10);	           //0.1ms
											 Time++;
											 err--;
											 if(Time>30)
											 {return;}
											}
									IrValue[k]>>=1;	          //k表示第几组数据
									if(Time>=8)			          //如果高电平出现大于565us,那么是1
											{
											 IrValue[k]|=0x80;
											}
									Time=0;		                //用完时间要重新赋值							
								}
			   }
			}
		 if(IrValue[2]!=~IrValue[3])           //校验
			 {return;}
	 }
}
#endif
